# Generated by Mistral 7B via Ollama

class Solution:
    def cheapestJump(self, coins, maxJump):
        visited = set()
        q = [(1, 0)]
        while q:
            index, cost = q.pop(0)
            if index == len(coins):
                return list(reversed(visited))

            for k in range(1, min(maxJump+1, len(coins)-index+1)):
                next_index = index + k
                if 0 < next_index <= len(coins) and coins[next_index] != -1:
                    next_cost = cost + coins[next_index]
                    if next_index == len(coins) or (next_index < len(coins) and coins[next_index+1] == -1):
                        if next_cost < self.cheapest_jump[next_index] or (next_index not in visited):
                            q.append((next_index, next_cost))
                            visited.add(next_index)

        return []

