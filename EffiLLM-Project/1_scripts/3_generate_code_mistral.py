import os
import subprocess
import re

# === CONFIGURATION ===
BASE_DIR = "2_problems"
PROMPT_DIR = "gpt_prompts_ready"
LEVELS = ["easy", "medium", "hard"]
MODEL = "mistral"
TIMEOUT = 300  # seconds

# === Extract function name from human.py ===
def extract_method_name(human_code):
    match = re.search(r"def (\w+)\s*\(", human_code)
    return match.group(1) if match else None

# === Wrap code inside class Solution ===
def wrap_in_class(code, method_name):
    lines = code.strip().split("\n")
    if lines[0].strip().startswith("class Solution"):
        return code
    indented = ["    " + line if line.strip() else "" for line in lines]
    return f"class Solution:\n" + "\n".join(indented)

# === Generate Python code using Ollama + Mistral ===
def generate_code(prompt, method_name):
    system_prompt = (
        f"You are an expert Python developer. Solve the following problem. "
        f"Use the exact function name `{method_name}` and wrap it inside `class Solution`. "
        f"Only output raw Python code. Do not include explanations, comments, markdown, or extra text."
    )
    full_prompt = f"{system_prompt}\n\n{prompt}"

    try:
        result = subprocess.run(
            ["ollama", "run", MODEL],
            input=full_prompt.encode("utf-8"),
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            timeout=TIMEOUT
        )
        output = result.stdout.decode("utf-8")

        # Extract clean Python code from output
        match = re.findall(r"```(?:python)?\s*(.*?)```", output, re.DOTALL)
        code = match[0] if match else output

        # Fix incorrect function name if needed
        code = re.sub(r"def\s+\w+\s*\(", f"def {method_name}(", code, count=1)
        return wrap_in_class(code, method_name)

    except Exception as e:
        return f"# ‚ö†Ô∏è Generation error: {e}"

# === Loop through all problem folders ===
for level in LEVELS:
    level_path = os.path.join(BASE_DIR, level)
    if not os.path.isdir(level_path):
        continue

    for dp_folder in sorted(os.listdir(level_path)):
        problem_path = os.path.join(level_path, dp_folder)
        human_path = os.path.join(problem_path, "human.py")
        mistral_path = os.path.join(problem_path, "mistral.py")

        # === Build prompt file name ===
        prompt_file = f"{level}_dp_{dp_folder.split('_')[1]}.txt"
        prompt_path = os.path.join(PROMPT_DIR, prompt_file)

        if not os.path.exists(prompt_path) or not os.path.exists(human_path):
            print(f"‚ö†Ô∏è Skipping {dp_folder} ‚Äî missing prompt or human.py")
            continue

        if os.path.exists(mistral_path):
            print(f"üü° Already exists: {mistral_path}")
            continue

        with open(prompt_path, "r", encoding="utf-8") as f:
            prompt = f.read()

        with open(human_path, "r", encoding="utf-8") as f:
            human_code = f.read()

        method_name = extract_method_name(human_code)
        if not method_name:
            print(f"‚ùå Method name not found in {dp_folder}")
            continue

        print(f"üöÄ Generating with Mistral for {dp_folder} ‚Üí `{method_name}`")
        code = generate_code(prompt, method_name)

        with open(mistral_path, "w", encoding="utf-8") as f:
            f.write(f"# Generated by Mistral 7B via Ollama\n\n{code}\n")

        print(f"‚úÖ Saved to {mistral_path}")
